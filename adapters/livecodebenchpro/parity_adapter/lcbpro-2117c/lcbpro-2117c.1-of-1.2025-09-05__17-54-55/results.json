{
    "id": "b7291700-465e-46f9-9be7-5eaa55c3dc74",
    "trial_name": "lcbpro-2117c.1-of-1.2025-09-05__17-54-55",
    "task_id": "lcbpro-2117c",
    "instruction": "LiveCodeBench Pro (Mini) - external judge.\n\nThe agent must create a C++17 solution file at /app/main.cpp.\nThis task does not include local test cases. Instead, the test harness:\n  1) POSTs the code to the external judge (/submit) to get a sid,\n  2) polls GET /result/{sid}?short=1 until status == \"done\",\n  3) passes only if the judge returns passed == true.\n\nEnvironment variables (overridable at runtime):\n  - BASE_URL: judge base URL (default http://38.80.122.117:8081)\n  - PID: problem id (default 2117C)\n  - LANG: language (default cpp)\n  - CODE_PATH: path to code (default /app/main.cpp)\n  - JUDGE_TIMEOUT_SECS: poll timeout seconds (default 120)\n\nYousef has an array $a$ of size $n$. He wants to partition the array into one or more contiguous segments such that each element $a_i$ belongs to exactly one segment.\n\nA partition is called cool if, for every segment $b_j$, all elements in $b_j$ also appear in $b_{j + 1}$ (if it exists). That is, every element in a segment must also be present in the segment following it.\n\nFor example, if $a = [1, 2, 2, 3, 1, 5]$, a cool partition Yousef can make is $b_1 = [1, 2]$, $b_2 = [2, 3, 1, 5]$. This is a cool partition because every element in $b_1$ (which are $1$ and $2$) also appears in $b_2$. In contrast, $b_1 = [1, 2, 2]$, $b_2 = [3, 1, 5]$ is not a cool partition, since $2$ appears in $b_1$ but not in $b_2$.\n\nNote that after partitioning the array, you do not change the order of the segments. Also, note that if an element appears several times in some segment $b_j$, it only needs to appear at least once in $b_{j + 1}$.\n\nYour task is to help Yousef by finding the maximum number of segments that make a cool partition.\n\n### Input\n\nThe first line of the input contains integer $t$ ($1 \\le t \\le 10^4$) -- the number of test cases.\n\nThe first line of each test case contains an integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) -- the size of the array.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le n$) -- the elements of the array.\n\nIt is guaranteed that the sum of $n$ over all test cases doesn't exceed $2 \\cdot 10^5$.\n\n### Output\n\nFor each test case, print one integer -- the maximum number of segments that make a cool partition.\n\n### Example\n\n#### Input #1\n\n```\n\n8\n\n6\n\n1 2 2 3 1 5\n\n8\n\n1 2 1 3 2 1 3 2\n\n5\n\n5 4 3 2 1\n\n10\n\n5 8 7 5 8 5 7 8 10 9\n\n3\n\n1 2 2\n\n9\n\n3 3 1 4 3 2 4 1 2\n\n6\n\n4 5 4 5 6 4\n\n8\n\n1 2 1 2 1 2 1 2\n\n```\n\n#### Output #1\n\n```\n2\n3\n1\n3\n1\n3\n3\n4\n```\n\n### Note\n\nThe first test case is explained in the statement. We can partition it into $b_1 = [1, 2]$, $b_2 = [2, 3, 1, 5]$. It can be shown there is no other partition with more segments.\n\nIn the second test case, we can partition the array into $b_1 = [1, 2]$, $b_2 = [1, 3, 2]$, $b_3 = [1, 3, 2]$. The maximum number of segments is $3$.\n\nIn the third test case, the only partition we can make is $b_1 = [5, 4, 3, 2, 1]$. Any other partition will not satisfy the condition. Therefore, the answer is $1$.",
    "is_resolved": false,
    "failure_mode": "unset",
    "parser_results": {
        "test_external_judge": "failed"
    },
    "recording_path": "2025-09-05__17-54-55/lcbpro-2117c/lcbpro-2117c.1-of-1.2025-09-05__17-54-55/sessions/agent.cast",
    "total_input_tokens": 1242,
    "total_output_tokens": 356,
    "trial_started_at": "2025-09-06T01:20:09.669881+00:00",
    "trial_ended_at": "2025-09-06T01:20:54.524013+00:00",
    "agent_started_at": "2025-09-06T01:20:24.224173+00:00",
    "agent_ended_at": "2025-09-06T01:20:30.220379+00:00",
    "test_started_at": "2025-09-06T01:20:33.894358+00:00",
    "test_ended_at": "2025-09-06T01:20:38.893587+00:00"
}