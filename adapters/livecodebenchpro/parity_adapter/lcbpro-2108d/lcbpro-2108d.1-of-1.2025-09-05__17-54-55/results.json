{
    "id": "ef272735-f203-4d2a-8a3e-a7834580ace9",
    "trial_name": "lcbpro-2108d.1-of-1.2025-09-05__17-54-55",
    "task_id": "lcbpro-2108d",
    "instruction": "LiveCodeBench Pro (Mini) - external judge.\n\nThe agent must create a C++17 solution file at /app/main.cpp.\nThis task does not include local test cases. Instead, the test harness:\n  1) POSTs the code to the external judge (/submit) to get a sid,\n  2) polls GET /result/{sid}?short=1 until status == \"done\",\n  3) passes only if the judge returns passed == true.\n\nEnvironment variables (overridable at runtime):\n  - BASE_URL: judge base URL (default http://38.80.122.117:8081)\n  - PID: problem id (default 2108D)\n  - LANG: language (default cpp)\n  - CODE_PATH: path to code (default /app/main.cpp)\n  - JUDGE_TIMEOUT_SECS: poll timeout seconds (default 120)\n\nThis is an interactive problem.\n\nYou found the numbers $k$ and $n$ in the attic, but lost two arrays $A$ and $B$.\n\nYou remember that:\n\n- $|A| + |B| = n$, the total length of the arrays is $n$.\n- $|A| \\geq k$ and $|B| \\geq k$, the length of each array is at least $k$.\n- The arrays consist only of numbers from $1$ to $k$.\n- If you take any $k$ consecutive elements from array $A$, they will all be different. Also, if you take any $k$ consecutive elements from array $B$, they will all be different.\n\nFortunately, a kind spirit that settled in the attic found these arrays and concatenated them into an array $C$ of length $n$. That is, the elements of array $A$ were first written into array $C$, followed by the elements of array $B$.\n\nYou can ask the kind spirit up to $250$ questions. Each question contains an index $i$ ($1 \\leq i \\leq n$). In response, you will receive the $i$-th element of the concatenated array $C$.\n\nYou need to find the lengths of arrays $A$ and $B$, or report that it is impossible to determine them uniquely.\n\n### Input\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 300$). The description of the test cases follows.\n\nThe only line of each test case contains two integers $n$ and $k$ ($1 \\leq k \\leq 50$, $2 k \\leq n \\leq 10^{6}$).\n\nNote that the sum of $n$ across test cases is not limited.\n\n### Interaction\n\nThe interaction for each test case begins with reading the integer $n$.\n\nThen you can make up to $250$ queries.\n\nTo make a query, output a string in the format \"? x\" (without quotes) ($1 \\leq x \\leq n$). After each query, read an integer -- the answer to your query.\n\nIf you make too many queries, you will receive a verdict of Wrong answer.\n\nTo report your answer, output a string in the format \"! a b\" (without quotes), where $a$ and $b$ are the lengths of arrays $A$ and $B$ that you found, respectively. The answer is not counted when counting the number of queries.\n\nIf it is impossible to determine the lengths of the arrays uniquely, output \"! -1\" (without quotes). Note that if you answer $-1$ while there is a sequence of at most $250$ queries that uniquely determines the lengths of arrays, you will get a Wrong answer verdict.\n\nIt is guaranteed that there are arrays $A$ and $B$ that do not contradict the statement, for which the interactor output is correct.\n\nThe interactor is not adaptive, which means that the answer is known before the participant makes queries and does not depend on the queries made by the participant.\n\nIf your program makes more than $250$ queries, your program should immediately terminate to receive the verdict Wrong answer. Otherwise, you can get an arbitrary verdict because your solution will continue to read from a closed stream.\n\nAfter outputting a query, do not forget to output a newline and flush the output buffer. Otherwise, you will receive a verdict of \"IL\" (Idleness limit exceeded). To flush the buffer, use:\n\n- fflush(stdout) or cout.flush() in C++;\n- System.out.flush() in Java;\n- flush(output) in Pascal;\n- stdout.flush() in Python;\n- see the documentation for other languages.\n\nHacks\n\nHacks are disabled for this problem.\n\n### Example\n\n#### Input #1\n\n```\n6\n5 2\n\n1\n\n2\n\n2\n\n18 4\n\n2\n\n4\n\n1\n\n1\n\n4\n\n3 1\n\n10 5\n\n9 3\n\n3\n\n3\n\n2\n\n12 4\n\n1\n\n3\n\n1\n\n3\n\n1\n\n3\n```\n\n#### Output #1\n\n```\n\n? 1\n\n? 2\n\n? 3\n\n! 2 3\n\n? 9\n\n? 13\n\n? 10\n\n? 14\n\n? 6\n\n! 9 9\n\n! -1\n\n! 5 5\n\n? 3\n\n? 6\n\n? 9\n\n! 6 3\n\n? 1\n\n? 2\n\n? 5\n\n? 6\n\n? 9\n\n? 10\n\n! -1\n```\n\n### Note\n\nConsider the first example. We queried the first $3$ elements out of $5$. Now we know that the array $C$ looks like $[1, 2, 2, ?, ?]$. We know for sure that the third element is not from array $A$ -- because according to the condition, any $k$ consecutive elements (in our case $k = 2$) in array $A$ are different. Thus, the third element is definitely located in array $B$. This means that the length of array $A$ is $2$, and the length of array $B$ is $3$.\n\nThe picture shows arrays from all test cases. The elements whose values were requested are marked in yellow.\n\n![](https://espresso.codeforces.com/1981313348269cab100360e478a64874954e4b27.png)",
    "is_resolved": false,
    "failure_mode": "unset",
    "parser_results": {
        "test_external_judge": "failed"
    },
    "recording_path": "2025-09-05__17-54-55/lcbpro-2108d/lcbpro-2108d.1-of-1.2025-09-05__17-54-55/sessions/agent.cast",
    "total_input_tokens": 1567,
    "total_output_tokens": 1180,
    "trial_started_at": "2025-09-06T01:28:58.413174+00:00",
    "trial_ended_at": "2025-09-06T01:32:05.196869+00:00",
    "agent_started_at": "2025-09-06T01:29:24.397748+00:00",
    "agent_ended_at": "2025-09-06T01:29:41.640875+00:00",
    "test_started_at": "2025-09-06T01:29:44.929651+00:00",
    "test_ended_at": "2025-09-06T01:31:48.793095+00:00"
}