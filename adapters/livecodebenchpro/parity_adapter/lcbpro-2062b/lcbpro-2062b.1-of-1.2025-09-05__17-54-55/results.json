{
    "id": "f18c8410-b3b1-44c7-b063-ee740822bcf6",
    "trial_name": "lcbpro-2062b.1-of-1.2025-09-05__17-54-55",
    "task_id": "lcbpro-2062b",
    "instruction": "LiveCodeBench Pro (Mini) - external judge.\n\nThe agent must create a C++17 solution file at /app/main.cpp.\nThis task does not include local test cases. Instead, the test harness:\n  1) POSTs the code to the external judge (/submit) to get a sid,\n  2) polls GET /result/{sid}?short=1 until status == \"done\",\n  3) passes only if the judge returns passed == true.\n\nEnvironment variables (overridable at runtime):\n  - BASE_URL: judge base URL (default http://38.80.122.117:8081)\n  - PID: problem id (default 2062B)\n  - LANG: language (default cpp)\n  - CODE_PATH: path to code (default /app/main.cpp)\n  - JUDGE_TIMEOUT_SECS: poll timeout seconds (default 120)\n\nYou have a sequence of $n$ time clocks arranged in a line, where the initial time on the $i$-th clock is $a_i$. In each second, the following happens in order:\n\n- Each clock's time decreases by $1$. If any clock's time reaches $0$, you lose immediately.\n- You can choose to move to an adjacent clock or stay at the clock you are currently on.\n- You can reset the time of the clock you are on back to its initial value $a_i$.\n\nNote that the above events happen in order. If the time of a clock reaches $0$ in a certain second, even if you can move to this clock and reset its time during that second, you will still lose.\n\nYou can start from any clock. Determine if it is possible to continue this process indefinitely without losing.\n\n### Input\n\nThe first line of input contains a single integer $t$ ($1 \\leq t \\leq 10^4$) -- the number of test cases.\n\nFor each test case, the first line contains a single integer $n$ ($2 \\leq n \\leq 5 \\cdot 10^5$) -- the number of time clocks.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^9$) -- the initial times set on the clocks.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5\\cdot 10^5$.\n\n### Output\n\nFor each test case, print \"YES\" (without quotes) if it is possible to continue this process indefinitely, or \"NO\" (without quotes) otherwise.\n\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yEs\", \"yes\" and \"Yes\" will be recognized as a positive response).\n\n### Example\n\n#### Input #1\n\n```\n\n5\n\n2\n\n4 10\n\n2\n\n2 2\n\n3\n\n4 10 5\n\n3\n\n5 3 5\n\n5\n\n12 13 25 17 30\n\n```\n\n#### Output #1\n\n```\nYES\nNO\nNO\nYES\nYES\n```\n\n### Note\n\nIn the first test case, you can move back and forth between the two clocks, resetting them repeatedly.\n\nIn the third test case, assuming that you start from clock $1$ and follow the strategy below:\n\nInitially, $a=[4,10,5]$.\n\n1. $a$ becomes $[3, 9, 4]$. You move to clock $2$ and reset its time, resulting in $a=[3, 10, 4]$.\n2. $a$ becomes $[2, 9, 3]$. You move to clock $3$ and reset its time, resulting in $a=[2, 9, 5]$.\n3. $a$ becomes $[1, 8, 4]$. You move to clock $2$ and reset its time, resulting in $a=[1, 10, 4]$.\n4. $a$ becomes $[0, 9, 3]$. You move to clock $1$, but you lose because $a_1$ reaches $0$.\n\nIt can be proven that no other strategy allows you to continue this process indefinitely.",
    "is_resolved": false,
    "failure_mode": "unset",
    "parser_results": {
        "test_external_judge": "failed"
    },
    "recording_path": "2025-09-05__17-54-55/lcbpro-2062b/lcbpro-2062b.1-of-1.2025-09-05__17-54-55/sessions/agent.cast",
    "total_input_tokens": 1127,
    "total_output_tokens": 1842,
    "trial_started_at": "2025-09-06T01:23:26.755143+00:00",
    "trial_ended_at": "2025-09-06T01:24:48.657433+00:00",
    "agent_started_at": "2025-09-06T01:23:53.707232+00:00",
    "agent_ended_at": "2025-09-06T01:24:26.741354+00:00",
    "test_started_at": "2025-09-06T01:24:28.232560+00:00",
    "test_ended_at": "2025-09-06T01:24:31.200232+00:00"
}