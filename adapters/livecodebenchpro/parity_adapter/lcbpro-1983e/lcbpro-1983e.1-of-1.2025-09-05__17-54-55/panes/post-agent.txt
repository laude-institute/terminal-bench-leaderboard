root@e02e1d52f83c:/app# cat > /app/main.cpp << 'EOF'
> #include <bits/stdc++.h>
> using namespace std;
>
> const int MOD = 1e9+7;
>
> // Modular inverse using Fermat's little theorem
> long long modpow(long long base, long long exp, long long mod) {
>     long long result = 1;
>     while (exp > 0) {
>         if (exp & 1) result = result * base % mod;
>         base = base * base % mod;
>         exp >>= 1;
>     }
>     return result;
> }
>
> // Modular inverse under prime mod
> long long modinv(long long a, long long m = MOD) {
>     return modpow(a, m-2, m);
> }
>
> int main() {
>     ios::sync_with_stdio(false);
>     cin.tie(nullptr);
>
>     int t; cin >> t;
>
>     // Sum of all n across test cases <= 5*10^5, so no problem storing
>
>     while (t--) {
>         int n, k;
>         cin >> n >> k;
>         vector<int> v(n);
>         for (int i = 0; i < n; i++) {
>             cin >> v[i];
>         }
>
>         // Precompute prefix sums of special and non-special balls
>         // Special balls: first k
>         // Non-special: last n-k
>
>         // sumS = sum of special balls
>         // sumN = sum of non-special balls
>         long long sumS = 0, sumN = 0;
>         for (int i = 0; i < k; i++) sumS = (sumS + v[i]) % MOD;
>         for (int i = k; i < n; i++) sumN = (sumN + v[i]) % MOD;
>
>         // We want expected scores of Alice and Bob modulo MOD
>
>         // Let p = k, q = n-k
>         // Probability of picking special ball at any turn depends on remaining balls.
>
>         // After analysis (from editorial approach):
>         // Expected score Alice = sumS * (n+k)/(2*n) + sumN * (n-k)/(2*n)
>         // Expected score Bob = sumS * (n-k)/(2*n) + sumN * (n+k)/(2*n)
>
>         // Since the game is symmetric with turns switching on non-special ball picks,
>         // and special balls allow same player to play again,
>         // the expected scores are linear combinations of sums with coefficients derived from n and k.
>
>         // Let's derive:
>         // Expected Alice = (sumS * (n+k) + sumN * (n-k)) * modinv(2*n) mod M
>         // Expected Bob   = (sumS * (n-k) + sumN * (n+k)) * modinv(2*n) mod M
>
>         long long denom = (2LL * n) % MOD;
>         long long invDenom = modinv(denom);
>
>         long long alice = ((sumS * ((n + k) % MOD)) % MOD + (sumN * ((n - k + MOD) % MOD)) % MOD) % MOD;
>         alice = (alice * invDenom) % MOD;
>
>         long long bob = ((sumS * ((n - k + MOD) % MOD)) % MOD + (sumN * ((n + k) % MOD)) % MOD) % MOD;
>         bob = (bob * invDenom) % MOD;
>
>         cout << alice << ; tmux wait -S done
>
