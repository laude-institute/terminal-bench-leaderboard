{"version": 2, "width": 160, "height": 40, "timestamp": 1757121100, "env": {"SHELL": "/bin/bash", "TERM": "tmux-256color"}}
[0.074274, "o", "\u001b[?2004hroot@e02e1d52f83c:/app# "]
[0.681547, "i", "clear\r"]
[0.684662, "o", "clear\r\n\u001b[?2004l\r"]
[0.68693, "o", "\u001b[H\u001b[J\u001b[3J"]
[0.687878, "o", "\u001b[?2004hroot@e02e1d52f83c:/app# "]
[18.384056, "i", "cat > /app/main.cpp << 'EOF'\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9+7;\n\n// Modular inverse using Fermat's little theorem\nlong long modpow(long long base, long long exp, long long mod) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp & 1) result = result * base % mod;\n        base = base * base % mod;\n        exp >>= 1;\n    }\n    return result;\n}\n\n// Modular inverse under prime mod\nlong long modinv(long long a, long long m = MOD) {\n    return modpow(a, m-2, m);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t; cin >> t;\n\n    // Sum of all n across test cases <= 5*10^5, so no problem storing\n\n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n        vector<int> v(n);\n        for (int i = 0; i < n; i++) {\n            cin >> v[i];\n        }\n\n        // Precompute prefix sums of special and non-special balls\n        // Special balls: first k\n        // Non-special: last n-k\n\n        // sumS = sum of special balls\n        // sumN = sum of non-special balls\n        long long sumS = 0, sumN = 0;\n        for (int i = 0; i < k; i++) sumS = (sumS + v[i]) % MOD;\n        for (int i = k; i < n; i++) sumN = (sumN + v[i]) % MOD;\n\n        // We want expected scores of Alice and Bob modulo MOD\n\n        // Let p = k, q = n-k\n        // Probability of picking special ball at any turn depends on remaining balls.\n\n        // After analysis (from editorial approach):\n        // Expected score Alice = sumS * (n+k)/(2*n) + sumN * (n-k)/(2*n)\n        // Expected score Bob = sumS * (n-k)/(2*n) + sumN * (n+k)/(2*n)\n\n        // Since the game is symmetric with turns switching on non-special ball picks,\n        // and special balls allow same player to play again,\n        // the expected scores are linear combinations of sums with coefficients derived from n and k.\n\n        // Let's derive:\n        // Expected Alice = (sumS * (n+k) + sumN * (n-k)) * modinv(2*n) mod M\n        // Expected Bob   = (sumS * (n-k) + sumN * (n+k)) * modinv(2*n) mod M\n\n        long long denom = (2LL * n) % MOD;\n        long long invDenom = modinv(denom);\n\n        long long alice = ((sumS * ((n + k) % MOD)) % MOD + (sumN * ((n - k + MOD) % MOD)) % MOD) % MOD;\n        alice = (alice * invDenom) % MOD;\n\n        long long bob = ((sumS * ((n - k + MOD) % MOD)) % MOD + (sumN * ((n + k) % MOD)) % MOD) % MOD;\n        bob = (bob * invDenom) % MOD;\n\n        cout << alice << ; tmux wait -S done\r"]
[18.401103, "o", "cat > /app/main.cpp << 'EOF'\r\n\u001b[?2004l\r"]
[18.410088, "o", "\u001b[?2004h> #include <bits/stdc++.h>\r\n\u001b[?2004l\r\u001b[?2004h> using namespace std;\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h> const int MOD = 1e9+7;\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h> // Modular inverse using Fermat's little theorem\r\n\u001b[?2004l\r\u001b[?2004h> long long modpow(long long base, long long exp, long long mod) {\r\n\u001b[?2004l\r\u001b[?2004h>     long long result = 1;\r\n\u001b[?2004l\r\u001b[?2004h>     while (exp > 0) {\r\n\u001b[?2004l\r\u001b[?2004h>         if (exp & 1) result = result * base % mod;\r\n\u001b[?2004l\r\u001b[?2004h>         base = base * base % mod;\r\n\u001b[?2004l\r\u001b[?2004h>         exp >>= 1;\r\n\u001b[?2004l\r\u001b[?2004h>     }\r\n\u001b[?2004l\r\u001b[?2004h>     return result;\r\n\u001b[?2004l\r\u001b[?2004h> }\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h> // Modular inverse under prime mod\r\n\u001b[?2004l\r\u001b[?2004h> long long modinv(long long a, long long m = MOD) {\r\n\u001b[?2004l\r\u001b[?2004h>     return modpow(a, m-2, m);\r\n\u001b[?2004l\r\u001b[?2004h> }\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h> int main() {\r\n\u001b[?2004l\r\u001b[?2004h>     ios::sync_with_stdio(false);\r\n\u001b[?2004l\r\u001b[?2004h>     cin.tie(nullptr);\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h>     int t; cin >> t;\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h>     // Sum of all n across test cases <= 5*10^5, so no problem storing\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h>     while (t--) {\r\n\u001b[?2004l\r\u001b[?2004h>         int n, k;\r\n\u001b[?2004l\r\u001b[?2004h>         cin >> n >> k;\r\n\u001b[?2004l\r\u001b[?2004h>         vector<int> v(n);\r\n\u001b[?2004l\r\u001b[?2004h>         for (int i = 0; i < n; i++) {\r\n\u001b[?2004l\r\u001b[?2004h>             cin >> v[i];\r\n\u001b[?2004l\r"]
[18.469365, "o", "\u001b[?2004h>         }\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h>         // Precompute prefix sums of special and non-special balls\r\n\u001b[?2004l\r\u001b[?2004h>         // Special balls: first k\r\n\u001b[?2004l\r\u001b[?2004h>         // Non-special: last n-k\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h>         // sumS = sum of special balls\r\n\u001b[?2004l\r\u001b[?2004h>         // sumN = sum of non-special balls\r\n\u001b[?2004l\r\u001b[?2004h>         long long sumS = 0, sumN = 0;\r\n\u001b[?2004l\r\u001b[?2004h>         for (int i = 0; i < k; i++) sumS = (sumS + v[i]) % MOD;\r\n\u001b[?2004l\r\u001b[?2004h>         for (int i = k; i < n; i++) sumN = (sumN + v[i]) % MOD;\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h>         // We want expected scores of Alice and Bob modulo MOD\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h>         // Let p = k, q = n-k\r\n\u001b[?2004l\r\u001b[?2004h>         // Probability of picking special ball at any turn depends on remaining balls.\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h>         // After analysis (from editorial approach):\r\n\u001b[?2004l\r\u001b[?2004h>         // Expected score Alice = sumS * (n+k)/(2*n) + sumN * (n-k)/(2*n)\r\n\u001b[?2004l\r\u001b[?2004h>         // Expected score Bob = sumS * (n-k)/(2*n) + sumN * (n+k)/(2*n)\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h>         // Since the game is symmetric with turns switching on non-special ball picks,\r\n\u001b[?2004l\r\u001b[?2004h>         // and special balls allow same player to play again,\r\n\u001b[?2004l\r\u001b[?2004h>         // the expected scores are linear combinations of sums with coefficients derived from n and k.\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h>         // Let's derive:\r\n\u001b[?2004l\r\u001b[?2004h>         // Expected Alice = (sumS * (n+k) + sumN * (n-k)) * modinv(2*n) mod M\r\n\u001b[?2004l\r\u001b[?2004h>         // Expected Bob   = (sumS * (n-k) + sumN * (n+k)) * modinv(2*n) mod M\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h>         long long denom = (2LL * n) % MOD;\r\n\u001b[?2004l\r\u001b[?2004h>         long long invDenom = modinv(denom);\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h>         long long alice = ((sumS * ((n + k) % MOD)) % MOD + (sumN * ((n - k + MOD) % MOD)) % MOD) % MOD;\r\n\u001b[?2004l\r\u001b[?2004h>         alice = (alice * invDenom) % MOD;\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h>         long long bob = ((sumS * ((n - k + MOD) % MOD)) % MOD + (sumN * ((n + k) % MOD)) % MOD) % MOD;\r\n\u001b[?2004l\r\u001b[?2004h>         bob = (bob * invDenom) % MOD;\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h>         cout << alice << ; tmux wait -S done\r\n\u001b[?2004l\r\u001b[?2004h> "]
[206.25962, "i", "\u0004"]
[206.266884, "o", "\u001b[?2004l\r\r\nbash: warning: here-document at line 2 delimited by end-of-file (wanted `EOF')\r\n"]
[206.355146, "o", "\u001b[?2004hroot@e02e1d52f83c:/app# "]
